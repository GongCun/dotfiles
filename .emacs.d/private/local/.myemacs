;;; Some functions and hooks

;; (global-linum-mode 1)
(defun my-linum-mode-hook ()
  (when linum-mode
    (setq-local linum-format
                (let ((w (length (number-to-string
                                  (count-lines (point-min) (point-max))))))
                  (concat "%" (number-to-string w) "d ")))))
;; (add-hook 'linum-mode-hook #'my-linum-mode-hook)

(defun my-linum-format-string ()
  (setq-local linum-format
              (let ((w (length (number-to-string
                                (count-lines (point-min) (point-max))))))
                (concat "%" (number-to-string w) "d "))))
;; (add-hook 'linum-before-numbering-hook #'my-linum-format-string)

(add-hook 'prog-mode-hook 'linum-mode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun set-c-toggle-hungry-state()
  (c-toggle-hungry-state 1))

;; (add-hook 'c-mode-hook
;;           (lambda ()
;;             (c-set-style "linux")
;;             (flyspell-prog-mode)
;;             (turn-on-auto-fill)
;;             (c-toggle-auto-state 1)
;;             (c-toggle-auto-newline 1)
;;             ))
;; (add-hook 'c-mode-hook 'set-c-toggle-hungry-state)

(add-hook 'c++-mode-hook
          (lambda ()
            (c-set-style "stroustrup")
            (flyspell-prog-mode)
            (turn-on-auto-fill)
            (c-toggle-auto-state 1)
            ))
(add-hook 'c++-mode-hook 'set-c-toggle-hungry-state)

(c-add-style "linux"
             '((c-basic-offset . 4)
               (c-offsets-alist
                (statement-cont . c-lineup-assignments)
                (arglist-close . 0)
                )))

(c-add-style "stroustrup"
             '((c-basic-offset . 4)
               (c-offsets-alist
                (statement-cont . c-lineup-assignments)
                (arglist-close . 0)
                )))

(add-hook 'text-mode-hook
          (lambda ()
            (turn-on-auto-fill)
            (flyspell-prog-mode)))

(add-hook 'shell-script-mode-hook
          (lambda ()
            (turn-on-auto-fill)
            (flyspell-prog-mode)))

;; some customize keybind
(global-unset-key [f5])
(global-set-key [f5] 'abbrev-mode)
(global-unset-key [f6])
(global-set-key [f6] 'browse-url)
;; (global-set-key [f6] 'menu-bar-open)
(global-set-key [f7] 'holy-mode)
(global-set-key [f8] 'compile)
(global-set-key [f9] 'ispell-word)
(global-set-key [f10] 'flyspell-mode)
(global-set-key [f11] 'string-insert-rectangle)
;; (global-set-key [f12] 'linum-mode)
(global-set-key [f12] 'linum-relative-toggle)
(global-set-key (kbd "\C-xI") 'insert-buffer)

(progn
  (require 'dired)
  (define-key dired-mode-map (kbd "o") 'other-window)
  (define-key dired-mode-map (kbd "2") 'delete-window)
  (define-key dired-mode-map (kbd "3") 'delete-other-windows)
  (define-key dired-mode-map (kbd "4") 'split-window-below)
  (define-key dired-mode-map (kbd "C-o") 'find-file))

(add-hook 'org-mode-hook
          (lambda ()
            (setq org-indent-mode nil)
            (define-key org-mode-map "\C-cl" 'org-store-link)
            (define-key org-mode-map "\C-ca" 'org-agenda)))

;; (setq shell-file-name "c:/cygwin64/bin/bash.exe")
;; (setq shell-command-switch "-c")
;; (setq explicit-shell-file-name shell-file-name)
;; (setenv "SHELL" shell-file-name)
;; (setq explicit-sh-args '("-login" "-i"))
;; (if (boundp 'w32-quote-process-args)
;;     (setq w32-quote-process-args ?\")) ;; include only for MS Windows
;; (defun cygwin-shell ()
;;   "Run cygwin bash in shell mode."
;;   (interactive)
;;   (let ((explicit-shell-file-name "C:/cygwin64/bin/bash.exe"))
;;     (call-interactively 'shell)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; setup Emacs for using cygwin
;; From: https://www.emacswiki.org/emacs/setup-cygwin.el
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun setcyg-dir-p (directory)
  "Return DIRECTORY if DIRECTORY is a readable directory, nil otherwise."
  (and (stringp directory)  (file-directory-p directory)  (file-readable-p directory)  directory))

(defcustom cygwin-root-directory (or (setcyg-dir-p "C:/cygwin64/")  (setcyg-dir-p "C:/cygwin/"))
  "Root directory of Cygwin installation.
It should have subdirectories `bin' and `usr/info'.
Subdirectory `bin' should have file `bin/bash.exe'."
  :group 'setup-cygwin :type 'directory)

(unless (setcyg-dir-p cygwin-root-directory)
  (error "Cannot find Cygwin.  Please customize option `cygwin-root-directory'"))

;;; Use Unix-style line endings.
;; Per Eli Z. https://debbugs.gnu.org/cgi/bugreport.cgi?bug=21780#40:
;;
;; $$$$$$ (setq-default buffer-file-coding-system 'undecided-unix)
(setq-default buffer-file-coding-system (coding-system-change-eol-conversion
                                         (default-value 'buffer-file-coding-system)
                                         'unix))

;;; Use /dev/null, not NUL.
(setq null-device  "/dev/null")

;;; Without this env var setting, Cygwin causes `ediff-buffers', at least, to raise an error.
;;; Making this setting here might have no effect, as the env var is checked only by the first Cygwin process
;;; invoked during your Windows session.  For best results, set this env var globally, in Windows itself.
;;; An alternative might be to use `cygpath' to change from MS Windows file names to POSIX.
(setenv "CYGWIN" "nodosfilewarning")
(setenv "LC_ALL" "C")
(setenv "GIT_PAGER" "cat")
(setenv "DISPLAY" "127.0.0.1:5000")

;;; Add Cygwin Info pages
(add-to-list 'Info-default-directory-list (expand-file-name "usr/info" cygwin-root-directory) 'APPEND)

;;; Use `bash' as the default shell in Emacs.
(add-to-list 'exec-path (expand-file-name "bin" cygwin-root-directory))
(setq shell-file-name  (expand-file-name "bin/bash.exe" cygwin-root-directory)) ; Subprocesses invoked by shell.
(setenv "SHELL" shell-file-name)
;; (setenv "PATH" (concat (getenv "PATH") ";" (expand-file-name "bin" cygwin-root-directory)))
(setenv "PATH" (concat (expand-file-name "bin" cygwin-root-directory) ";" (getenv "PATH")))
(setq explicit-shell-file-name  shell-file-name) ; Interactive shell
(setq ediff-shell               shell-file-name)    ; Ediff shell
;; (setq explicit-shell-args       '("--login" "-i"))
(setq explicit-shell-args       '("--noediting"))

;;;;; (setq shell-command-switch "-ic") ; SHOULD THIS BE "-c" or "-ic"?
(setq w32-quote-process-args ?\") ;; " @@@ IS THIS BETTER? ;@@@ WAS THIS BEFORE: (setq w32-quote-process-args t)

;;;###autoload
(defun bash ()
  "Start `bash' shell."
  (interactive)
  (let ((binary-process-input t)
        (binary-process-output nil))
    (shell)))

(setq process-coding-system-alist
      (cons '("bash" . (raw-text-dos . raw-text-unix)) process-coding-system-alist))


;; From: http://www.dotfiles.com/files/6/235_.emacs
;;;###autoload
(defun set-shell-bash()
  "Enable on-the-fly switching between the bash shell and DOS."
  (interactive)
  ;; (setq binary-process-input t)
  (setq shell-file-name "bash")
  (setq shell-command-switch "-c")      ; SHOULD IT BE (setq shell-command-switch "-ic")?
  (setq explicit-shell-file-name "bash")
  (setenv "SHELL" explicit-shell-file-name)
  ;;;;;(setq explicit-sh-args '("-login" "-i")) ; Undefined?
  (setq w32-quote-process-args ?\") ;; "
  ;;;;;(setq mswindows-quote-process-args t)) ; Undefined?
  )
;; (set-shell-bash)
(setq shell-command-switch "-c")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; setup cywin ends here

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; open shell in the same buffer
;;; from: https://emacs.stackexchange.com/questions/28909/how-i-can-open-shell-in-current-buffer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require 'shell)

(defun shell-get-buffer-create (&optional buffer)
  "Run an inferior shell, with I/O through BUFFER (which defaults to `*shell*').
Interactively, a prefix arg means to prompt for BUFFER.
If `default-directory' is a remote file name, it is also prompted
to change if called with a prefix arg.

If BUFFER exists but shell process is not running, make new shell.
If BUFFER exists and shell process is running, just switch to BUFFER.
Program used comes from variable `explicit-shell-file-name',
 or (if that is nil) from the ESHELL environment variable,
 or (if that is nil) from `shell-file-name'.
If a file `~/.emacs_SHELLNAME' exists, or `~/.emacs.d/init_SHELLNAME.sh',
it is given as initial input (but this may be lost, due to a timing
error, if the shell discards input when it starts up).
The buffer is put in Shell mode, giving commands for sending input
and controlling the subjobs of the shell.  See `shell-mode'.
See also the variable `shell-prompt-pattern'.

To specify a coding system for converting non-ASCII characters
in the input and output to the shell, use \\[universal-coding-system-argument]
before \\[shell].  You can also specify this with \\[set-buffer-process-coding-system]
in the shell buffer, after you start the shell.
The default comes from `process-coding-system-alist' and
`default-process-coding-system'.

The shell file name (sans directories) is used to make a symbol name
such as `explicit-csh-args'.  If that symbol is a variable,
its value is used as a list of arguments when invoking the shell.
Otherwise, one argument `-i' is passed to the shell.

\(Type \\[describe-mode] in the shell buffer for a list of commands.)"
  (interactive
   (list
    (and current-prefix-arg
   (prog1
       (read-buffer "Shell buffer: "
        ;; If the current buffer is an inactive
        ;; shell buffer, use it as the default.
        (if (and (eq major-mode 'shell-mode)
           (null (get-buffer-process (current-buffer))))
            (buffer-name)
          (generate-new-buffer-name "*shell*")))
     (if (file-remote-p default-directory)
         ;; It must be possible to declare a local default-directory.
               ;; FIXME: This can't be right: it changes the default-directory
               ;; of the current-buffer rather than of the *shell* buffer.
         (setq default-directory
         (expand-file-name
          (read-directory-name
           "Default directory: " default-directory default-directory
           t nil))))))))
  (setq buffer (if (or buffer (not (derived-mode-p 'shell-mode))
                       (comint-check-proc (current-buffer)))
                   (get-buffer-create (or buffer "*shell*"))
                 ;; If the current buffer is a dead shell buffer, use it.
                 (current-buffer)))

  ;; On remote hosts, the local `shell-file-name' might be useless.
  (if (and (called-interactively-p 'any)
     (file-remote-p default-directory)
     (null explicit-shell-file-name)
     (null (getenv "ESHELL")))
      (with-current-buffer buffer
  (set (make-local-variable 'explicit-shell-file-name)
       (file-remote-p
        (expand-file-name
         (read-file-name
    "Remote shell path: " default-directory shell-file-name
    t shell-file-name))
        'localname))))

  ;; The buffer's window must be correctly set when we call comint (so
  ;; that comint sets the COLUMNS env var properly).
  (with-current-buffer buffer
    (unless (comint-check-proc buffer)
      (let* ((prog (or explicit-shell-file-name
           (getenv "ESHELL") shell-file-name))
       (name (file-name-nondirectory prog))
       (startfile (concat "~/.emacs_" name))
       (xargs-name (intern-soft (concat "explicit-" name "-args"))))
        (unless (file-exists-p startfile)
    (setq startfile (concat user-emacs-directory "init_" name ".sh")))
        (apply 'make-comint-in-buffer "shell" buffer prog
         (if (file-exists-p startfile) startfile)
         (if (and xargs-name (boundp xargs-name))
       (symbol-value xargs-name)
           '("-i")))
        (shell-mode))))
  buffer)

(defun my-display-buffer (buffer alist direction &optional size pixelwise)
"BUFFER:  The buffer that will be displayed.
ALIST:  See the doc-string of `display-buffer' for more information.
DIRECTION:  Must use one of these symbols:  'left 'right 'below 'above
SIZE:  See the doc-string for `split-window'.
PIXELWISE:  See the doc-string for `split-window'.
There are three possibilities:
-  (1) If a window on the frame already displays the target buffer,
then just reuse the same window.
-  (2) If there is already a window in the specified direction in relation
to the selected window, then display the target buffer in said window.
-  (3) If there is no window in the specified direction, then create one
in that direction and display the target buffer in said window."
  (let ((window
          (cond
            ((get-buffer-window buffer (selected-frame)))
            ((window-in-direction direction))
            (t
              (split-window (selected-window) size direction pixelwise)))))
    (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
    window))

(switch-to-buffer (shell-get-buffer-create))
;;; end of setup open eshell in current buffer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(require 'cl)
(require 'eshell)

(defun eshell-get-buffer-create (&optional arg)
  "Create an interactive Eshell buffer.  Return the Eshell buffer,
creating it if needed.  The buffer used for Eshell sessions is
determined by the value of `eshell-buffer-name'.  A numeric prefix
arg (as in `C-u 42 M-x eshell RET') switches to the session with
that number, creating it if necessary.  A nonnumeric prefix arg
means to createa new session.  Returns the buffer selected (or created)."
  (interactive "P")
  (cl-assert eshell-buffer-name)
  (let ((buf (cond ((numberp arg)
                    (get-buffer-create (format "%s<%d>"
                                               eshell-buffer-name
                                               arg)))
                   (arg
                    (generate-new-buffer eshell-buffer-name))
                   (t
                    (get-buffer-create eshell-buffer-name)))))
    (cl-assert (and buf (buffer-live-p buf)))
    (with-current-buffer buf
      (unless (derived-mode-p 'eshell-mode)
        (eshell-mode)))
    buf))

(pop-to-buffer-same-window (eshell-get-buffer-create))

;;; end of setup open eshell current buffer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
